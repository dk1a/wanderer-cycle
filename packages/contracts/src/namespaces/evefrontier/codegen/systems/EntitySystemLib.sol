// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

/* Autogenerated file. Do not edit manually. */

import { EntitySystem } from "../../EntitySystem.sol";
import { TagId } from "@eveworld/smart-object-framework-v2/src/libs/TagId.sol";
import { ResourceId } from "@latticexyz/world/src/WorldResourceId.sol";
import { revertWithBytes } from "@latticexyz/world/src/revertWithBytes.sol";
import { IWorldCall } from "@latticexyz/world/src/IWorldKernel.sol";
import { SystemCall } from "@latticexyz/world/src/SystemCall.sol";
import { WorldContextConsumerLib } from "@latticexyz/world/src/WorldContext.sol";
import { Systems } from "@latticexyz/world/src/codegen/tables/Systems.sol";
import { ResourceId } from "@latticexyz/store/src/ResourceId.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";

type EntitySystemType is bytes32;

// equivalent to WorldResourceIdLib.encode({ typeId: RESOURCE_SYSTEM, namespace: "evefrontier", name: "EntitySystem" }))
EntitySystemType constant entitySystem = EntitySystemType.wrap(
  0x737965766566726f6e74696572000000456e7469747953797374656d00000000
);

struct CallWrapper {
  ResourceId systemId;
  address from;
}

struct RootCallWrapper {
  ResourceId systemId;
  address from;
}

/**
 * @title EntitySystemLib
 * @author MUD (https://mud.dev) by Lattice (https://lattice.xyz)
 * @dev This library is automatically generated from the corresponding system contract. Do not edit manually.
 */
library EntitySystemLib {
  error EntitySystemLib_CallingFromRootSystem();
  error Entity_InvalidEntityId(uint256 entityId);
  error Entity_EntityAlreadyExists(uint256 entityId);
  error Entity_EntityDoesNotExist(uint256 classId);
  error Entity_PropertyTagNotFound(uint256 entityId, TagId tagId);
  error Entity_EntityRelationsFound(uint256 classId, uint256 numOfTags);
  error Entity_BadRoleConfirmation();
  error Entity_RoleDoesNotExist(bytes32 role);

  function registerClass(
    EntitySystemType self,
    ResourceId[] memory scopedSystemIds
  ) internal returns (uint256 classId) {
    return CallWrapper(self.toResourceId(), address(0)).registerClass(scopedSystemIds);
  }

  function instantiate(
    EntitySystemType self,
    uint256 classId,
    address accessRoleMember
  ) internal returns (uint256 objectId) {
    return CallWrapper(self.toResourceId(), address(0)).instantiate(classId, accessRoleMember);
  }

  function addToScope(EntitySystemType self, uint256 entityId, ResourceId[] memory scopedSystemIds) internal {
    return CallWrapper(self.toResourceId(), address(0)).addToScope(entityId, scopedSystemIds);
  }

  function setClassAccessRole(EntitySystemType self, uint256 classId, bytes32 newAccessRole) internal {
    return CallWrapper(self.toResourceId(), address(0)).setClassAccessRole(classId, newAccessRole);
  }

  function deleteClass(EntitySystemType self, uint256 classId) internal {
    return CallWrapper(self.toResourceId(), address(0)).deleteClass(classId);
  }

  function deleteClasses(EntitySystemType self, uint256[] memory classIds) internal {
    return CallWrapper(self.toResourceId(), address(0)).deleteClasses(classIds);
  }

  function setObjectAccessRole(EntitySystemType self, uint256 objectId, bytes32 newAccessRole) internal {
    return CallWrapper(self.toResourceId(), address(0)).setObjectAccessRole(objectId, newAccessRole);
  }

  function deleteObject(EntitySystemType self, uint256 objectId) internal {
    return CallWrapper(self.toResourceId(), address(0)).deleteObject(objectId);
  }

  function deleteObjects(EntitySystemType self, uint256[] memory objectIds) internal {
    return CallWrapper(self.toResourceId(), address(0)).deleteObjects(objectIds);
  }

  function registerClass(
    CallWrapper memory self,
    ResourceId[] memory scopedSystemIds
  ) internal returns (uint256 classId) {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert EntitySystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeCall(_registerClass_ResourceIdArray.registerClass, (scopedSystemIds));

    bytes memory result = self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
    return abi.decode(result, (uint256));
  }

  function instantiate(
    CallWrapper memory self,
    uint256 classId,
    address accessRoleMember
  ) internal returns (uint256 objectId) {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert EntitySystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeCall(_instantiate_uint256_address.instantiate, (classId, accessRoleMember));

    bytes memory result = self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
    return abi.decode(result, (uint256));
  }

  function addToScope(CallWrapper memory self, uint256 entityId, ResourceId[] memory scopedSystemIds) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert EntitySystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeCall(
      _addToScope_uint256_ResourceIdArray.addToScope,
      (entityId, scopedSystemIds)
    );
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function setClassAccessRole(CallWrapper memory self, uint256 classId, bytes32 newAccessRole) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert EntitySystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeCall(
      _setClassAccessRole_uint256_bytes32.setClassAccessRole,
      (classId, newAccessRole)
    );
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function deleteClass(CallWrapper memory self, uint256 classId) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert EntitySystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeCall(_deleteClass_uint256.deleteClass, (classId));
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function deleteClasses(CallWrapper memory self, uint256[] memory classIds) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert EntitySystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeCall(_deleteClasses_uint256Array.deleteClasses, (classIds));
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function setObjectAccessRole(CallWrapper memory self, uint256 objectId, bytes32 newAccessRole) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert EntitySystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeCall(
      _setObjectAccessRole_uint256_bytes32.setObjectAccessRole,
      (objectId, newAccessRole)
    );
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function deleteObject(CallWrapper memory self, uint256 objectId) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert EntitySystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeCall(_deleteObject_uint256.deleteObject, (objectId));
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function deleteObjects(CallWrapper memory self, uint256[] memory objectIds) internal {
    // if the contract calling this function is a root system, it should use `callAsRoot`
    if (address(_world()) == address(this)) revert EntitySystemLib_CallingFromRootSystem();

    bytes memory systemCall = abi.encodeCall(_deleteObjects_uint256Array.deleteObjects, (objectIds));
    self.from == address(0)
      ? _world().call(self.systemId, systemCall)
      : _world().callFrom(self.from, self.systemId, systemCall);
  }

  function registerClass(
    RootCallWrapper memory self,
    ResourceId[] memory scopedSystemIds
  ) internal returns (uint256 classId) {
    bytes memory systemCall = abi.encodeCall(_registerClass_ResourceIdArray.registerClass, (scopedSystemIds));

    bytes memory result = SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
    return abi.decode(result, (uint256));
  }

  function instantiate(
    RootCallWrapper memory self,
    uint256 classId,
    address accessRoleMember
  ) internal returns (uint256 objectId) {
    bytes memory systemCall = abi.encodeCall(_instantiate_uint256_address.instantiate, (classId, accessRoleMember));

    bytes memory result = SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
    return abi.decode(result, (uint256));
  }

  function addToScope(RootCallWrapper memory self, uint256 entityId, ResourceId[] memory scopedSystemIds) internal {
    bytes memory systemCall = abi.encodeCall(
      _addToScope_uint256_ResourceIdArray.addToScope,
      (entityId, scopedSystemIds)
    );
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function setClassAccessRole(RootCallWrapper memory self, uint256 classId, bytes32 newAccessRole) internal {
    bytes memory systemCall = abi.encodeCall(
      _setClassAccessRole_uint256_bytes32.setClassAccessRole,
      (classId, newAccessRole)
    );
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function deleteClass(RootCallWrapper memory self, uint256 classId) internal {
    bytes memory systemCall = abi.encodeCall(_deleteClass_uint256.deleteClass, (classId));
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function deleteClasses(RootCallWrapper memory self, uint256[] memory classIds) internal {
    bytes memory systemCall = abi.encodeCall(_deleteClasses_uint256Array.deleteClasses, (classIds));
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function setObjectAccessRole(RootCallWrapper memory self, uint256 objectId, bytes32 newAccessRole) internal {
    bytes memory systemCall = abi.encodeCall(
      _setObjectAccessRole_uint256_bytes32.setObjectAccessRole,
      (objectId, newAccessRole)
    );
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function deleteObject(RootCallWrapper memory self, uint256 objectId) internal {
    bytes memory systemCall = abi.encodeCall(_deleteObject_uint256.deleteObject, (objectId));
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function deleteObjects(RootCallWrapper memory self, uint256[] memory objectIds) internal {
    bytes memory systemCall = abi.encodeCall(_deleteObjects_uint256Array.deleteObjects, (objectIds));
    SystemCall.callWithHooksOrRevert(self.from, self.systemId, systemCall, msg.value);
  }

  function callFrom(EntitySystemType self, address from) internal pure returns (CallWrapper memory) {
    return CallWrapper(self.toResourceId(), from);
  }

  function callAsRoot(EntitySystemType self) internal view returns (RootCallWrapper memory) {
    return RootCallWrapper(self.toResourceId(), WorldContextConsumerLib._msgSender());
  }

  function callAsRootFrom(EntitySystemType self, address from) internal pure returns (RootCallWrapper memory) {
    return RootCallWrapper(self.toResourceId(), from);
  }

  function toResourceId(EntitySystemType self) internal pure returns (ResourceId) {
    return ResourceId.wrap(EntitySystemType.unwrap(self));
  }

  function fromResourceId(ResourceId resourceId) internal pure returns (EntitySystemType) {
    return EntitySystemType.wrap(resourceId.unwrap());
  }

  function getAddress(EntitySystemType self) internal view returns (address) {
    return Systems.getSystem(self.toResourceId());
  }

  function _world() private view returns (IWorldCall) {
    return IWorldCall(StoreSwitch.getStoreAddress());
  }
}

/**
 * System Function Interfaces
 *
 * We generate an interface for each system function, which is then used for encoding system calls.
 * This is necessary to handle function overloading correctly (which abi.encodeCall cannot).
 *
 * Each interface is uniquely named based on the function name and parameters to prevent collisions.
 */

interface _registerClass_ResourceIdArray {
  function registerClass(ResourceId[] memory scopedSystemIds) external;
}

interface _instantiate_uint256_address {
  function instantiate(uint256 classId, address accessRoleMember) external;
}

interface _addToScope_uint256_ResourceIdArray {
  function addToScope(uint256 entityId, ResourceId[] memory scopedSystemIds) external;
}

interface _setClassAccessRole_uint256_bytes32 {
  function setClassAccessRole(uint256 classId, bytes32 newAccessRole) external;
}

interface _deleteClass_uint256 {
  function deleteClass(uint256 classId) external;
}

interface _deleteClasses_uint256Array {
  function deleteClasses(uint256[] memory classIds) external;
}

interface _setObjectAccessRole_uint256_bytes32 {
  function setObjectAccessRole(uint256 objectId, bytes32 newAccessRole) external;
}

interface _deleteObject_uint256 {
  function deleteObject(uint256 objectId) external;
}

interface _deleteObjects_uint256Array {
  function deleteObjects(uint256[] memory objectIds) external;
}

using EntitySystemLib for EntitySystemType global;
using EntitySystemLib for CallWrapper global;
using EntitySystemLib for RootCallWrapper global;

// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

/* Autogenerated file. Do not edit manually. */

// Import store internals
import { ResourceId } from "@latticexyz/store/src/ResourceId.sol";
import { EncodeArray } from "@latticexyz/store/src/tightcoder/EncodeArray.sol";

// Import idx internals
import { Uint8Map, Uint8MapLib } from "@dk1a/mud-table-idxs/src/Uint8Map.sol";
import { hashIndexes, hashValues } from "@dk1a/mud-table-idxs/src/utils.sol";

import { IIdxErrors } from "@dk1a/mud-table-idxs/src/IIdxErrors.sol";

import { registerUniqueIdx } from "@dk1a/mud-table-idxs/src/namespaces/uniqueIdx/registerUniqueIdx.sol";
import { UniqueIdx } from "@dk1a/mud-table-idxs/src/namespaces/uniqueIdx/codegen/tables/UniqueIdx.sol";

// Import user types
import { StatmodTopic } from "../../StatmodTopic.sol";
import { StatmodOp, EleStat } from "../../../../codegen/common.sol";

library UniqueIdx_StatmodBase_StatmodTopicStatmodOpEleStat {
  // Hex below is the result of `WorldResourceIdLib.encode({ namespace: "statmod", name: "StatmodBase", typeId: RESOURCE_TABLE });`
  ResourceId constant _tableId = ResourceId.wrap(0x7462737461746d6f6400000000000000537461746d6f64426173650000000000);

  uint256 constant _keyNumber = 0;
  uint256 constant _fieldNumber = 3;

  Uint8Map constant _keyIndexes = Uint8Map.wrap(0x0000000000000000000000000000000000000000000000000000000000000000);
  Uint8Map constant _fieldIndexes = Uint8Map.wrap(0x0300010200000000000000000000000000000000000000000000000000000000);

  bytes32 constant _indexesHash = 0xe9234a2d6f7a08a62c3b839e205f151250dceb9d57822ca73f9cd8112b5f03bd;

  function valuesHash(StatmodTopic statmodTopic, StatmodOp statmodOp, EleStat eleStat) internal pure returns (bytes32) {
    bytes32[] memory _partialKeyTuple = new bytes32[](_keyNumber);

    bytes[] memory _partialValues = new bytes[](_fieldNumber);

    _partialValues[0] = abi.encodePacked(StatmodTopic.unwrap(statmodTopic));

    _partialValues[1] = abi.encodePacked(uint8(statmodOp));

    _partialValues[2] = abi.encodePacked(uint8(eleStat));

    return hashValues(_partialKeyTuple, _partialValues);
  }

  // Should be called once in e.g. PostDeploy
  function register() internal {
    registerUniqueIdx(_tableId, _keyIndexes, _fieldIndexes);
  }

  function has(StatmodTopic statmodTopic, StatmodOp statmodOp, EleStat eleStat) internal view returns (bool) {
    bytes32 _valuesHash = valuesHash(statmodTopic, statmodOp, eleStat);

    return UniqueIdx.length(_tableId, _indexesHash, _valuesHash) > 0;
  }

  function getKeyTuple(
    StatmodTopic statmodTopic,
    StatmodOp statmodOp,
    EleStat eleStat
  ) internal view returns (bytes32[] memory _keyTuple) {
    bytes32 _valuesHash = valuesHash(statmodTopic, statmodOp, eleStat);

    _keyTuple = UniqueIdx.get(_tableId, _indexesHash, _valuesHash);

    if (_keyTuple.length == 0) {
      revert IIdxErrors.UniqueIdx_InvalidGet({
        tableId: _tableId,
        libraryName: "UniqueIdx_StatmodBase_StatmodTopicStatmodOpEleStat",
        valuesBlob: abi.encodePacked(statmodTopic, statmodOp, eleStat),
        indexesHash: _indexesHash,
        valuesHash: _valuesHash
      });
    }
  }

  function get(StatmodTopic statmodTopic, StatmodOp statmodOp, EleStat eleStat) internal view returns (bytes32 entity) {
    bytes32[] memory _keyTuple = getKeyTuple(statmodTopic, statmodOp, eleStat);

    entity = _keyTuple[0];
  }

  /**
   * @notice Decode keys from a bytes32 array using the source table's field layout.
   */
  function decodeKeyTuple(bytes32[] memory _keyTuple) internal pure returns (bytes32 entity) {
    entity = _keyTuple[0];
  }
}
